テストコードが書けるメリット
============================================================

一度書いたコードは改善（変更）を免れない
============================================================

* 持てる知識を全て動員して書いたが、より適切な文法を知らなかった
* **新しく知った書き方** で書き直したい ➡️ 学びになり、Pythonの力がつく💪

.. Pythonがバージョンアップして文法自体が進化

例：FizzBuzz
--------------------------------------------------

.. code-block:: python

    def fizzbuzz(number: int) -> str:
        if number % 3 == 0 and number % 5 == 0:
            return "FizzBuzz"
        elif number % 3 == 0:
            return "Fizz"
        elif number % 5 == 0:
            return "Buzz"
        else:
            return str(number)

https://pycamp.pycon.jp/textbook/2_intro.html#fizzbuzz リスト2.14

Structural Pattern Matching (Python 3.10〜)
--------------------------------------------------

.. code-block:: python

    def fizzbuzz(number: int) -> str:
        match number % 3, number % 5:
            case 0, 0: return "FizzBuzz"
            case 0, _: return "Fizz"
            case _, 0: return "Buzz"
            case _, _: return str(number)

https://gihyo.jp/news/report/01/pyconjp2021/0002

裏で「`Introduction to Structural Pattern Matching <https://2023-apac.pycon.jp/timetable?id=DXWXGJ>`__」

書き換えで振る舞いを変えていないだろうか？
============================================================

**不安** に対処するいくつかのアプローチ

.. fear（不安）

(A) 祈る ⛩
--------------------------------------------------

* 🙏🙏「どうか変わっていませんように」🙏🙏
* 振る舞いを変えていないか不安だが、 *何も確認はしない*

(B) 手で動作確認 ✋
--------------------------------------------------

* 例えば対話的に ``fizzbuzz`` 関数を実行

.. code-block:: pycon

    >>> from fizzbuzz import fizzbuzz  # doctest: +SKIP
    >>> fizzbuzz(15)  # doctest: +SKIP
    'FizzBuzz'

* 安心できるが、 *関数の数が増えて* いくと現実的ではなさそう

(C) コードを書いて動作確認 🤖
--------------------------------------------------

* この発表の本題
* 「手で動作確認」の **自動化** （テストコードを書く）
* プログラムで使う部品のコードは、プログラムを書いて動作確認するという考え方

.. 「単体テスト」はAppendix？

テストコードの用語紹介
--------------------------------------------------

テストコードを実行すると、 **pass** （全て通る・成功）または **fail** （1つでも失敗・落ちる）

.. code-block:: pycon
    :caption: かしこまった書き方

    >>> actual = fizzbuzz(15)  # テスト対象を実行した値 # doctest: +SKIP
    >>> expected = "FizzBuzz"  # 期待結果
    >>> actual == expected
    True

テストコードがあると
============================================================

.. list-table:: ``actual == expected`` を **簡単に確認** できる

    * - actual
      - expected
    * - ``fizzbuzz(3)``
      - ``"Fizz"``
    * - ``fizzbuzz(5)``
      - ``"Buzz"``
    * - ``fizzbuzz(15)``
      - ``"FizzBuzz"``

不安は退屈に変わる
--------------------------------------------------

* 実装中、仕様を満たす **動作するコード** であると確認できる🙌
* 書き換える際も、おかしくしていたら気付ける 🙌（*回帰テスト*）

.. テストが全てpassすれば、書き換えで変更していない
.. テストが1つでもfailしたら、書き換えで何かおかしくしてしまった（気づける）

書くコードは増えている、けれど
--------------------------------------------------

* 実装に加えてテストコードも書く
* でも、デメリット **<< メリット** だと思うから、📣練習して書けるようになるんだ！

🥟テストコードはPythonの力をつける下地（N=1）
============================================================

* テストコードにより、「この実装は仕様を満たす **動作** するコード」と **確認** できる
* 新しく知った文法を試して書き換えるとき、 **誤** って振る舞いを変えてしまっても **気づける**
