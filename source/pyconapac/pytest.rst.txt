pytest
============================================================

* サードパーティライブラリ https://pypi.org/project/pytest/
* :command:`pip install pytest`
* ヒミツ：古くは py.test だった（`Issue#1629 <https://github.com/pytest-dev/pytest/issues/1629>`__）

.. pytestはサードパーティライブラリで、デファクトスタンダードと言えるかもしれません。
    pip installして使っていきます。

pytestで書くテストは **3** ステップ
============================================================

1. テストコードのファイルを作る
2. テストコードとして、関数を書く
3. assert文

.. pytestをどう使うかですが、3つの手順をやればよいです。
    1つずつ見ていきましょう。

Step1 pytestの規則に従った **ファイル**
--------------------------------------------------

* ``test_`` で始まるPythonファイルを作成

.. code-block:: txt

    .
    ├── fizzbuzz.py
    └── test_fizzbuzz.py

.. まず、pytestの規則に従った名前のファイルを作ります。
    test_ で始まるPythonファイルを作ってください

Step2 pytestの規則に従った **関数**
--------------------------------------------------

* ``test_`` で始まる関数を書く

.. code-block:: python
    :caption: test_fizzbuzz.py

    def test_3の倍数のときはFizzを返す():
        ...

.. 次に test_ で始まるファイルの中に test_ で始まる関数を書きます。
    私の意見ですが、関数名は日本語を使ってもよいと思います

Step3 Pythonの **assert文**
--------------------------------------------------

* ``assert 式``
* 式が ``True`` と評価されるかを検証

https://docs.python.org/ja/3/reference/simple_stmts.html#the-assert-statement

.. 関数の内容ですが、assert文を使います。
    assertというキーワードの後に式を置くだけます。
    式が True と評価されるかを検証します。
    例を見てみましょう

assert文の例 1/2
--------------------------------------------------

.. code-block:: pycon

    >>> 1 == 1
    True
    >>> assert 1 == 1

.. 式が 1 イコール 1 と置くと、これはTrueなので何も表示されません。

assert文の例 2/2
--------------------------------------------------

.. code-block:: pycon

    >>> 1 == 2
    False
    >>> assert 1 == 2
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    AssertionError

.. 別の例で 1 イコール 2 という式はFalseと評価されるので、AssertionErrorが送出されます。
    以上の要素を使ってpytestのテストを書きます。

3Aでとらえるpytest
--------------------------------------------------

.. code-block:: python
    :caption: test_fizzbuzz.py

    def test_3の倍数のときはFizzを返す():
        number = 3  # Arrange
          # Act & Assert (actual == expected)
        assert fizzbuzz(number) == "Fizz"

.. これは3の倍数のときにFizzが返るかを検証するテストです。
    1つの関数の中で3Aを行います。
    Arrangeの行があり、
    ActとAssertは1つの行にまとまっています。

テスト実行 :command:`pytest -v`
--------------------------------------------------

.. code-block::

    .
    ├── fizzbuzz.py
    └── test_fizzbuzz.py

.. code-block:: shell

    $ pytest -v
    ============================= test session starts ==============================
    
    collected 5 items

    ============================== 5 passed in 0.01s ===============================

.. fizzbuzzの実装のファイルとテストのファイルを配置し、pytest -v コマンドでテストを実行します。
    これはテストが全てpassしています

failしたテスト（15でFizzを返した）
--------------------------------------------------

.. code-block:: shell

    test_fizzbuzz.py::test_15の倍数のときはFizzBuzzを返す FAILED             [ 20%]

    =================================== FAILURES ===================================
    __________________________ test_15の倍数のときはFizzBuzzを返す ___________________________

        def test_15の倍数のときはFizzBuzzを返す():
    >       assert fizzbuzz(15) == "FizzBuzz"
    E       AssertionError: assert 'Fizz' == 'FizzBuzz'
    E         - FizzBuzz
    E         + Fizz

* assert文だが、 **なぜAssertionErrorかが分かりやすい**

.. 試しに失敗させてみましょう。
    とてもわかりやすくないですか？ pytest -vのおかげです。
    AssertionErrorについても、期待値がFizzBuzzだが実際の値はFizzと、どこが間違っているか一目瞭然です。

pytestは **assert文を拡張**
--------------------------------------------------

* テストコードに使うのはassert文だけと **簡単**
* failしたテストの理由が **分かりやすい**

  * 秘密は *pytestがassert文を書き換え* ている（`assertion rewriting <https://docs.pytest.org/en/latest/how-to/writing_plugins.html#assertion-rewriting>`__）

.. なぜこんなことができるかというと
    人が書くのはassert文だけです。
    裏でpytestが頑張ってくれていて、failしたテストの理由がとてもわかりやすいです。
    pytestの特徴の1つです

pytestで **docstringの対話例も** 実行できる🏃‍♂️
--------------------------------------------------

* :command:`pytest --doctest-modules`
* https://docs.pytest.org/en/stable/how-to/doctest.html

.. docstring中の対話例も実行できるので、doctestで書いたテストを書き直す必要もないです！

tips (1/2) パラメタ化テスト
============================================================

.. code-block:: python

    def test_3の倍数のときはFizzを返す():
        ...

.. tips的な話題としてパラメタ化テストを紹介します。
    3の倍数のときにFizzを返すテストですが

3の倍数ならFizz
--------------------------------------------------

``number`` の **取りうる値は複数**

* 3
* 6
* 9

.. 3の倍数の値は複数あります。
    その中で3と6のケースをテストするとします

個別にテストの関数を書く？
--------------------------------------------------

.. code-block:: python

    def test_3の倍数のときはFizzを返す_3の場合():
        ...

    def test_3の倍数のときはFizzを返す_6の場合():
        ...

.. では個別にテストを書くのでしょうか？
    書いてもいいですが、楽はしたいですよね

``@pytest.mark.parametrize`` を使おう
--------------------------------------------------

.. literalinclude:: ../../samplecode/python-testing/pytest-example/test_fizzbuzz.py
    :language: python
    :pyobject: test_3の倍数のときはFizzを返す

.. 楽をするテクニックとして pytest.mark.parametrize というデコレータがあります

1つの関数、複数のテストケース
--------------------------------------------------

.. code-block:: shell

    $ pytest -v

    test_fizzbuzz.py::test_3の倍数のときはFizzを返す[3] PASSED               [ 40%]
    test_fizzbuzz.py::test_3の倍数のときはFizzを返す[6] PASSED               [ 60%]

**個別に書いたのと同じ** 結果が得られる

.. このデコレータを使うと、1つの関数だがテストケースとしては複数あるとして扱われます。
    3のケースと6のケースと2個分テストケースがあるということです。
    個別に書いたのと同じ結果です

tips (2/2) モック
============================================================

やや発展的話題（いまは分からなかったとしても大丈夫）

.. もう1つのtipsとしては、発展的なので難しかった〜としても大丈夫ですが、
    モックという概念があります

複数の処理を呼び出す実装のテストコードを書く
--------------------------------------------------

* テストを書きたい関数 ``foo``
* 処理A -> B -> Cの順で呼び出している

.. literalinclude:: ../../samplecode/python-testing/pytest-example/test_with_mock.py
    :language: python
    :pyobject: foo

.. fizzbuzzの例はとても単純でしたが、
    ある関数の中で別の関数を順番に呼び出す場合、その関数はどうテストしましょう？

.. TODO 時間がかかる関数など

どうテストコードを書くか？
--------------------------------------------------

* 全ての処理を通したテストも書ける
* 推し：呼び出される処理を **ニセモノ（＝モック）に置き換え** てテスト

.. 処理A,B,C全部を通してテストしてもよいと思います。
    私の意見としては、呼び出される処理を偽物に置き換えてテストします。
    この偽物がモックです

モックを使ったテスト
--------------------------------------------------

* ``foo`` 関数で呼び出す各処理を *何もしない* （＝モック）に置き換える
* **モックは呼び出され方を記憶** している
* 処理Aがこれこれを引数に呼び出されたかをAssertする

.. モックというのは関数のように振る舞うが実態は何もしないというものです。
    どういうふうに呼び出されたかを覚えていて、呼び出し方をassertします

モックを使ったテストの例
--------------------------------------------------

.. literalinclude:: ../../samplecode/python-testing/pytest-example/test_with_mock.py
    :language: python
    :pyobject: test_foo

* 処理の **呼び出しを検証**
* 処理A,B,C自体はいずれも別途、徹底的に検証

.. いきなり目にすると圧倒されるかもしれませんが、
    a_funcはモックで実際にa_func関数は呼び出されません。
    ただこの関数が42を引数に呼び出されることだけを検証しています。
    また、モックにした各関数はそれぞれのテストコードの中で徹底的に検証しています

🥟pytest まとめ
============================================================

* **test_** で始まるファイル
* **test_** で始まる関数。 **assert文** を使う
* テストに慣れてきたらぜひ試してみてください！

.. pytestをまとめると
    test_で始まるファイルにtest_で始まる関数を書いて、中でassert文を使います。
    テストに慣れてきたら試してみてください。書きやすいと思います
