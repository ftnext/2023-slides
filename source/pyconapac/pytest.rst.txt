pytest
============================================================

* ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ©ã‚¤ãƒ–ãƒ©ãƒª https://pypi.org/project/pytest/
* :command:`pip install pytest`
* ãƒ’ãƒŸãƒ„ï¼šå¤ãã¯ py.test ã ã£ãŸï¼ˆ`Issue#1629 <https://github.com/pytest-dev/pytest/issues/1629>`__ï¼‰

.. pytest is a third-party library, and it might be fair to say it's the de facto standard.
    You can use it after installing it with pip.

.. pytestã¯ã‚µãƒ¼ãƒ‰ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã€ãƒ‡ãƒ•ã‚¡ã‚¯ãƒˆã‚¹ã‚¿ãƒ³ãƒ€ãƒ¼ãƒ‰ã¨è¨€ãˆã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚
    pip installã—ã¦ä½¿ã£ã¦ã„ãã¾ã™ã€‚

pytestã§æ›¸ããƒ†ã‚¹ãƒˆã¯ **3** ã‚¹ãƒ†ãƒƒãƒ—
============================================================

1. ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œã‚‹
2. ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã¨ã—ã¦ã€é–¢æ•°ã‚’æ›¸ã
3. assertæ–‡

.. As for how to use pytest, there are three main steps.
    Let's go over each one.

.. pytestã‚’ã©ã†ä½¿ã†ã‹ã§ã™ãŒã€3ã¤ã®æ‰‹é †ã‚’ã‚„ã‚Œã°ã‚ˆã„ã§ã™ã€‚
    1ã¤ãšã¤è¦‹ã¦ã„ãã¾ã—ã‚‡ã†ã€‚

Step1 pytestã®è¦å‰‡ã«å¾“ã£ãŸ **ãƒ•ã‚¡ã‚¤ãƒ«**
--------------------------------------------------

* ``test_`` ã§å§‹ã¾ã‚‹Pythonãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ

.. code-block:: txt

    .
    â”œâ”€â”€ fizzbuzz.py
    â””â”€â”€ test_fizzbuzz.py

.. First, create a file following the pytest naming conventions.
    Please create a Python file that starts with test_(underscore)

.. ã¾ãšã€pytestã®è¦å‰‡ã«å¾“ã£ãŸåå‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œã‚Šã¾ã™ã€‚
    test_ ã§å§‹ã¾ã‚‹Pythonãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œã£ã¦ãã ã•ã„

Step2 pytestã®è¦å‰‡ã«å¾“ã£ãŸ **é–¢æ•°**
--------------------------------------------------

* ``test_`` ã§å§‹ã¾ã‚‹é–¢æ•°ã‚’æ›¸ã

.. code-block:: python
    :caption: test_fizzbuzz.py

    def test_3ã®å€æ•°ã®ã¨ãã¯Fizzã‚’è¿”ã™():
        ...

.. Next, inside the file starting with test_(underscore), you'll write functions that also start with test_.
    This might be a personal preference, but I believe it's okay to use Japanese in the function names.

.. æ¬¡ã« test_ ã§å§‹ã¾ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¸­ã« test_ ã§å§‹ã¾ã‚‹é–¢æ•°ã‚’æ›¸ãã¾ã™ã€‚
    ç§ã®æ„è¦‹ã§ã™ãŒã€é–¢æ•°åã¯æ—¥æœ¬èªã‚’ä½¿ã£ã¦ã‚‚ã‚ˆã„ã¨æ€ã„ã¾ã™

Step3 Pythonã® **assertæ–‡**
--------------------------------------------------

* ``assert å¼``
* å¼ãŒ ``True`` ã¨è©•ä¾¡ã•ã‚Œã‚‹ã‹ã‚’æ¤œè¨¼

https://docs.python.org/ja/3/reference/simple_stmts.html#the-assert-statement

.. The contents of these functions will make use of the assert statement.
    Place an expression after the assert keyword.
    It will verify if the expression is evaluated as True.
    Let's see an example.

.. é–¢æ•°ã®å†…å®¹ã§ã™ãŒã€assertæ–‡ã‚’ä½¿ã„ã¾ã™ã€‚
    assertã¨ã„ã†ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®å¾Œã«å¼ã‚’ç½®ãã ã‘ã¾ã™ã€‚
    å¼ãŒ True ã¨è©•ä¾¡ã•ã‚Œã‚‹ã‹ã‚’æ¤œè¨¼ã—ã¾ã™ã€‚
    ä¾‹ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†

assertæ–‡ã®ä¾‹ 1/2
--------------------------------------------------

.. code-block:: pycon

    >>> 1 == 1
    True
    >>> assert 1 == 1

.. If you set the expression as 1 equals 1, since it's True, nothing will be displayed.

.. å¼ãŒ 1 ã‚¤ã‚³ãƒ¼ãƒ« 1 ã¨ç½®ãã¨ã€ã“ã‚Œã¯Trueãªã®ã§ä½•ã‚‚è¡¨ç¤ºã•ã‚Œã¾ã›ã‚“ã€‚

assertæ–‡ã®ä¾‹ 2/2
--------------------------------------------------

.. code-block:: pycon

    >>> 1 == 2
    False
    >>> assert 1 == 2
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    AssertionError

.. On the other hand, if you set the expression as 1 equals 2,
    it's evaluated as False, and an AssertionError will be raised.
    Using the above steps, you'll write tests with pytest.

.. åˆ¥ã®ä¾‹ã§ 1 ã‚¤ã‚³ãƒ¼ãƒ« 2 ã¨ã„ã†å¼ã¯Falseã¨è©•ä¾¡ã•ã‚Œã‚‹ã®ã§ã€AssertionErrorãŒé€å‡ºã•ã‚Œã¾ã™ã€‚
    ä»¥ä¸Šã®è¦ç´ ã‚’ä½¿ã£ã¦pytestã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ãã¾ã™ã€‚

3Aã§ã¨ã‚‰ãˆã‚‹pytest
--------------------------------------------------

.. code-block:: python
    :caption: test_fizzbuzz.py

    def test_3ã®å€æ•°ã®ã¨ãã¯Fizzã‚’è¿”ã™():
        number = 3  # Arrange
          # Act & Assert (actual == expected)
        assert fizzbuzz(number) == "Fizz"

.. Here's a test verifying that Fizz is returned for multiples of 3.
    We write the 3A within a function.
    There's a line for 'Arrange',
    and 'Act' and 'Assert' are combined into a single line.

.. ã“ã‚Œã¯3ã®å€æ•°ã®ã¨ãã«FizzãŒè¿”ã‚‹ã‹ã‚’æ¤œè¨¼ã™ã‚‹ãƒ†ã‚¹ãƒˆã§ã™ã€‚
    1ã¤ã®é–¢æ•°ã®ä¸­ã§3Aã‚’è¡Œã„ã¾ã™ã€‚
    Arrangeã®è¡ŒãŒã‚ã‚Šã€
    Actã¨Assertã¯1ã¤ã®è¡Œã«ã¾ã¨ã¾ã£ã¦ã„ã¾ã™ã€‚

ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ :command:`pytest -v`
--------------------------------------------------

.. code-block::

    .
    â”œâ”€â”€ fizzbuzz.py
    â””â”€â”€ test_fizzbuzz.py

.. code-block:: shell

    $ pytest -v
    ============================= test session starts ==============================
    
    collected 5 items

    ============================== 5 passed in 0.01s ===============================

.. Put the implementation file and the test file,
    then run the tests using the pytest -v command.
    In this case, all the tests have passed.

.. fizzbuzzã®å®Ÿè£…ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¨ãƒ†ã‚¹ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é…ç½®ã—ã€pytest -v ã‚³ãƒãƒ³ãƒ‰ã§ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
    ã“ã‚Œã¯ãƒ†ã‚¹ãƒˆãŒå…¨ã¦passã—ã¦ã„ã¾ã™

failã—ãŸãƒ†ã‚¹ãƒˆï¼ˆ15ã§Fizzã‚’è¿”ã—ãŸï¼‰
--------------------------------------------------

.. code-block:: shell

    test_fizzbuzz.py::test_15ã®å€æ•°ã®ã¨ãã¯FizzBuzzã‚’è¿”ã™ FAILED             [ 20%]

    =================================== FAILURES ===================================
    __________________________ test_15ã®å€æ•°ã®ã¨ãã¯FizzBuzzã‚’è¿”ã™ ___________________________

        def test_15ã®å€æ•°ã®ã¨ãã¯FizzBuzzã‚’è¿”ã™():
    >       assert fizzbuzz(15) == "FizzBuzz"
    E       AssertionError: assert 'Fizz' == 'FizzBuzz'
    E         - FizzBuzz
    E         + Fizz

* assertæ–‡ã ãŒã€ **ãªãœAssertionErrorã‹ãŒåˆ†ã‹ã‚Šã‚„ã™ã„**

.. Let's deliberately make one test fail.
    Isn't the output very clear? Thanks to pytest -v.
    About AssertionError, you can easily see where the issue lies, such as expecting FizzBuzz but the actual value is Fizz.

.. è©¦ã—ã«å¤±æ•—ã•ã›ã¦ã¿ã¾ã—ã‚‡ã†ã€‚
    ã¨ã¦ã‚‚ã‚ã‹ã‚Šã‚„ã™ããªã„ã§ã™ã‹ï¼Ÿ pytest -vã®ãŠã‹ã’ã§ã™ã€‚
    AssertionErrorã«ã¤ã„ã¦ã‚‚ã€æœŸå¾…å€¤ãŒFizzBuzzã ãŒå®Ÿéš›ã®å€¤ã¯Fizzã¨ã€ã©ã“ãŒé–“é•ã£ã¦ã„ã‚‹ã‹ä¸€ç›®ç­ç„¶ã§ã™ã€‚

pytestã¯ **assertæ–‡ã‚’æ‹¡å¼µ**
--------------------------------------------------

* ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã«ä½¿ã†ã®ã¯assertæ–‡ã ã‘ã¨ **ç°¡å˜**
* failã—ãŸãƒ†ã‚¹ãƒˆã®ç†ç”±ãŒ **åˆ†ã‹ã‚Šã‚„ã™ã„**

  * ç§˜å¯†ã¯ *pytestãŒassertæ–‡ã‚’æ›¸ãæ›ãˆ* ã¦ã„ã‚‹ï¼ˆ`assertion rewriting <https://docs.pytest.org/en/latest/how-to/writing_plugins.html#assertion-rewriting>`__ï¼‰

.. What brings such clarity?
    All we have to write are the assert statements.
    Behind the scenes, pytest works hard to provide very understandable reasons when tests fail.
    This is one of the features of pytest.

.. ãªãœã“ã‚“ãªã“ã¨ãŒã§ãã‚‹ã‹ã¨ã„ã†ã¨
    äººãŒæ›¸ãã®ã¯assertæ–‡ã ã‘ã§ã™ã€‚
    è£ã§pytestãŒé ‘å¼µã£ã¦ãã‚Œã¦ã„ã¦ã€failã—ãŸãƒ†ã‚¹ãƒˆã®ç†ç”±ãŒã¨ã¦ã‚‚ã‚ã‹ã‚Šã‚„ã™ã„ã§ã™ã€‚
    pytestã®ç‰¹å¾´ã®1ã¤ã§ã™

pytestã§ **docstringã®å¯¾è©±ä¾‹ã‚‚** å®Ÿè¡Œã§ãã‚‹ğŸƒâ€â™‚ï¸
--------------------------------------------------

* :command:`pytest --doctest-modules`
* https://docs.pytest.org/en/stable/how-to/doctest.html

.. You can also run the interactive examples inside the docstring,
    so there's no need to rewrite tests you've created using doctest!

.. docstringä¸­ã®å¯¾è©±ä¾‹ã‚‚å®Ÿè¡Œã§ãã‚‹ã®ã§ã€doctestã§æ›¸ã„ãŸãƒ†ã‚¹ãƒˆã‚’æ›¸ãç›´ã™å¿…è¦ã‚‚ãªã„ã§ã™ï¼

tips (1/2) ãƒ‘ãƒ©ãƒ¡ã‚¿åŒ–ãƒ†ã‚¹ãƒˆ
============================================================

.. code-block:: python

    def test_3ã®å€æ•°ã®ã¨ãã¯Fizzã‚’è¿”ã™():
        ...

.. As a tip, I'd like to introduce parameterized tests.
    We want to check if Fizz is returned for multiples of 3.

.. tipsã¨ã—ã¦ãƒ‘ãƒ©ãƒ¡ã‚¿åŒ–ãƒ†ã‚¹ãƒˆã‚’ç´¹ä»‹ã—ã¾ã™ã€‚
    3ã®å€æ•°ã®ã¨ãã«Fizzã‚’è¿”ã™ãƒ†ã‚¹ãƒˆã§ã™ãŒ

3ã®å€æ•°ãªã‚‰Fizz
--------------------------------------------------

``number`` ã® **å–ã‚Šã†ã‚‹å€¤ã¯è¤‡æ•°**

* 3
* 6
* 9

.. There are many values that are multiples of 3.
    Among these, let's say we want to test for the cases of 3 and 6.

.. 3ã®å€æ•°ã®å€¤ã¯è¤‡æ•°ã‚ã‚Šã¾ã™ã€‚
    ãã®ä¸­ã§3ã¨6ã®ã‚±ãƒ¼ã‚¹ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã¨ã—ã¾ã™

å€‹åˆ¥ã«ãƒ†ã‚¹ãƒˆã®é–¢æ•°ã‚’æ›¸ãï¼Ÿ
--------------------------------------------------

.. code-block:: python

    def test_3ã®å€æ•°ã®ã¨ãã¯Fizzã‚’è¿”ã™_3ã®å ´åˆ():
        ...

    def test_3ã®å€æ•°ã®ã¨ãã¯Fizzã‚’è¿”ã™_6ã®å ´åˆ():
        ...

.. Would you write separate tests for each?
    While you can, it's always nice to find a more efficient way.

.. ã§ã¯å€‹åˆ¥ã«ãƒ†ã‚¹ãƒˆã‚’æ›¸ãã®ã§ã—ã‚‡ã†ã‹ï¼Ÿ
    æ›¸ã„ã¦ã‚‚ã„ã„ã§ã™ãŒã€æ¥½ã¯ã—ãŸã„ã§ã™ã‚ˆã­

``@pytest.mark.parametrize`` ã‚’ä½¿ãŠã†
--------------------------------------------------

.. literalinclude:: ../../samplecode/python-testing/pytest-example/test_fizzbuzz.py
    :language: python
    :pyobject: test_3ã®å€æ•°ã®ã¨ãã¯Fizzã‚’è¿”ã™

.. To streamline the process, there's a decorator called pytest.mark.parametrize.

.. æ¥½ã‚’ã™ã‚‹ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ã¨ã—ã¦ pytest.mark.parametrize ã¨ã„ã†ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™

1ã¤ã®é–¢æ•°ã€è¤‡æ•°ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
--------------------------------------------------

.. code-block:: shell

    $ pytest -v

    test_fizzbuzz.py::test_3ã®å€æ•°ã®ã¨ãã¯Fizzã‚’è¿”ã™[3] PASSED               [ 40%]
    test_fizzbuzz.py::test_3ã®å€æ•°ã®ã¨ãã¯Fizzã‚’è¿”ã™[6] PASSED               [ 60%]

**å€‹åˆ¥ã«æ›¸ã„ãŸã®ã¨åŒã˜** çµæœãŒå¾—ã‚‰ã‚Œã‚‹

.. By using this decorator, a single function is treated as if it has multiple test cases.
    This means, for this example, there are two test cases, one for 3 and another for 6.
    The outcome is the same as if you had written them separately.

.. ã“ã®ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ã†ã¨ã€1ã¤ã®é–¢æ•°ã ãŒãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã¨ã—ã¦ã¯è¤‡æ•°ã‚ã‚‹ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚
    3ã®ã‚±ãƒ¼ã‚¹ã¨6ã®ã‚±ãƒ¼ã‚¹ã¨2å€‹åˆ†ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ãŒã‚ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚
    å€‹åˆ¥ã«æ›¸ã„ãŸã®ã¨åŒã˜çµæœã§ã™

tips (2/2) ãƒ¢ãƒƒã‚¯
============================================================

ã‚„ã‚„ç™ºå±•çš„è©±é¡Œï¼ˆã„ã¾ã¯åˆ†ã‹ã‚‰ãªã‹ã£ãŸã¨ã—ã¦ã‚‚å¤§ä¸ˆå¤«ï¼‰

.. Another tip, which might be advanced and may feel difficult, is the concept of "mock".

.. ã‚‚ã†1ã¤ã®tipsã¨ã—ã¦ã¯ã€ç™ºå±•çš„ãªã®ã§é›£ã—ã‹ã£ãŸã€œã¨ã—ã¦ã‚‚å¤§ä¸ˆå¤«ã§ã™ãŒã€
    ãƒ¢ãƒƒã‚¯ã¨ã„ã†æ¦‚å¿µãŒã‚ã‚Šã¾ã™

è¤‡æ•°ã®å‡¦ç†ã‚’å‘¼ã³å‡ºã™å®Ÿè£…ã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã
--------------------------------------------------

* ãƒ†ã‚¹ãƒˆã‚’æ›¸ããŸã„é–¢æ•° ``foo``
* å‡¦ç†A -> B -> Cã®é †ã§å‘¼ã³å‡ºã—

.. literalinclude:: ../../samplecode/python-testing/pytest-example/test_with_mock.py
    :language: python
    :pyobject: foo

.. How would you test a function that sequentially calls other functions?

.. ã‚ã‚‹é–¢æ•°ã®ä¸­ã§åˆ¥ã®é–¢æ•°ã‚’é †ç•ªã«å‘¼ã³å‡ºã™å ´åˆã¯ã©ã†ãƒ†ã‚¹ãƒˆã—ã¾ã—ã‚‡ã†ï¼Ÿ

ã©ã†ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã‹ï¼Ÿ
--------------------------------------------------

* æ¨ã—ï¼šå‘¼ã³å‡ºã•ã‚Œã‚‹å‡¦ç†ã‚’ **ãƒ‹ã‚»ãƒ¢ãƒï¼ˆï¼ãƒ¢ãƒƒã‚¯ï¼‰ã«ç½®ãæ›ãˆ** ã¦ãƒ†ã‚¹ãƒˆ
* å…¨ã¦ã®å‡¦ç†ã‚’é€šã—ãŸãƒ†ã‚¹ãƒˆã‚‚æ›¸ã‘ã‚‹

.. In my opinion, you would replace the called processes with fakes when testing.
    These fakes are called "mocks".

.. ç§ã®æ„è¦‹ã¨ã—ã¦ã¯ã€å‘¼ã³å‡ºã•ã‚Œã‚‹å‡¦ç†ã‚’å½ç‰©ã«ç½®ãæ›ãˆã¦ãƒ†ã‚¹ãƒˆã—ã¾ã™ã€‚
    ã“ã®å½ç‰©ãŒãƒ¢ãƒƒã‚¯ã§ã™

ãƒ¢ãƒƒã‚¯ã‚’ä½¿ã£ãŸãƒ†ã‚¹ãƒˆ
--------------------------------------------------

* ``foo`` é–¢æ•°ã§å‘¼ã³å‡ºã™å„å‡¦ç†ã‚’ãƒ†ã‚¹ãƒˆã«ãŠã„ã¦ *ä½•ã‚‚ã—ãªã„* ï¼ˆï¼ãƒ¢ãƒƒã‚¯ï¼‰ã«ç½®ãæ›ãˆã‚‹
* **ãƒ¢ãƒƒã‚¯ã¯å‘¼ã³å‡ºã•ã‚Œæ–¹ã‚’è¨˜æ†¶** ã—ã¦ã„ã‚‹

.. Mocks can be called, but they don't execute the actual functions.
    They remember how they were called.

.. ãƒ¢ãƒƒã‚¯ã¯å‘¼ã³å‡ºã›ã‚‹ãŒã€æœ¬ç‰©ã®é–¢æ•°ã®å‡¦ç†ã¯ã—ã¾ã›ã‚“ã€‚
    ã©ã†ã„ã†ãµã†ã«å‘¼ã³å‡ºã•ã‚ŒãŸã‹ã‚’è¦šãˆã¦ã„ã¾ã™

ãƒ¢ãƒƒã‚¯ã‚’ä½¿ã£ãŸãƒ†ã‚¹ãƒˆã®ä¾‹
--------------------------------------------------

.. literalinclude:: ../../samplecode/python-testing/pytest-example/test_with_mock.py
    :language: python
    :pyobject: test_foo

* å‡¦ç†ã® **å‘¼ã³å‡ºã—ã‚’æ¤œè¨¼**
* å‡¦ç†A,B,Cè‡ªä½“ã¯ã„ãšã‚Œã‚‚åˆ¥é€”ã€å¾¹åº•çš„ã«æ¤œè¨¼

.. While it might be overwhelming when you first encounter it,
    the function a_func is mocked and the actual a_func isn't executed.
    The test is only verifying that a_func is called with the argument 42(forty-two).
    Additionally, each function that has been mocked is thoroughly verified within its respective test code.

.. ã„ããªã‚Šç›®ã«ã™ã‚‹ã¨åœ§å€’ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€
    a_funcã¯ãƒ¢ãƒƒã‚¯ã§å®Ÿéš›ã«a_funcé–¢æ•°ã¯å®Ÿè¡Œã•ã‚Œã¾ã›ã‚“ã€‚
    ãŸã ã“ã®é–¢æ•°ãŒ42ã‚’å¼•æ•°ã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã ã‘ã‚’æ¤œè¨¼ã—ã¦ã„ã¾ã™ã€‚
    ã¾ãŸã€ãƒ¢ãƒƒã‚¯ã«ã—ãŸå„é–¢æ•°ã¯ãã‚Œãã‚Œã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®ä¸­ã§å¾¹åº•çš„ã«æ¤œè¨¼ã—ã¦ã„ã¾ã™

ãƒ¢ãƒƒã‚¯ã®ä½¿ã„æ‰€
--------------------------------------------------

* æ™‚é–“ã®ã‹ã‹ã‚‹é–¢æ•°ï¼ˆãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œæ™‚é–“ãŒä¼¸ã³ã‚‹ï¼‰
* å¤–éƒ¨ã¨é€šä¿¡ã™ã‚‹é–¢æ•°ï¼ˆé€šä¿¡ã‚¨ãƒ©ãƒ¼ã§ãƒ†ã‚¹ãƒˆãŒè½ã¡ã†ã‚‹ï¼‰
* å‡ºåŠ›ãŒå¤‰ã‚ã‚‹é–¢æ•°ï¼ˆä¾‹ï¼šrandomï¼‰

.. From experience, I tend to use mocks for functions that take a long time,
    functions that communicate externally, and functions where the output varies.

.. çµŒé¨“ä¸Šãƒ¢ãƒƒã‚¯ã‚’ç©æ¥µçš„ã«ä½¿ã„ãŸã„ã®ã¯ã€æ™‚é–“ã®ã‹ã‹ã‚‹é–¢æ•°ã€å¤–éƒ¨ã¨é€šä¿¡ã™ã‚‹é–¢æ•°ã€å‡ºåŠ›ãŒå¤‰ã‚ã‚‹é–¢æ•°ã§ã™ã€‚

ğŸ¥Ÿpytest ã¾ã¨ã‚
============================================================

* **test_** ã§å§‹ã¾ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãƒ» **test_** ã§å§‹ã¾ã‚‹é–¢æ•°ãƒ» **assertæ–‡**
* tips: ãƒ‘ãƒ©ãƒ¡ã‚¿åŒ– & ãƒ¢ãƒƒã‚¯
* ãƒ†ã‚¹ãƒˆã«æ…£ã‚Œã¦ããŸã‚‰ãœã²è©¦ã—ã¦ã¿ã¦ãã ã•ã„ï¼

.. To summarize pytest,
    You write functions starting with test_ inside files that also start with test_,
    and you use the assert statement.
    two tips: parametrize and mock.
    Once you get familiar with testing, give pytest a try. I think you'll find it easy to write.

.. pytestã‚’ã¾ã¨ã‚ã‚‹ã¨
    test_ã§å§‹ã¾ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã«test_ã§å§‹ã¾ã‚‹é–¢æ•°ã‚’æ›¸ã„ã¦ã€ä¸­ã§assertæ–‡ã‚’ä½¿ã„ã¾ã™ã€‚
    ãƒ†ã‚¹ãƒˆã«æ…£ã‚Œã¦ããŸã‚‰è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚æ›¸ãã‚„ã™ã„ã¨æ€ã„ã¾ã™
